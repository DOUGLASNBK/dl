#include <unistd.h>
#include <stddef.h>
#include <string.h>
#include <stdint.h>

#include "trampoline.h"

#define MAX_STACK_COUNT 100
#define MAX_INTEGER_COUNT (6)
#define MAX_FLOAT_COUNT (8)

#define _xstr(s) _str(s)
#define _str(s) #s

int
call(void *f, void **args, int *flags, int count, void **out)
{
    void *ret;
    void *fret;
    void *integers[MAX_INTEGER_COUNT];
    void *floats[MAX_FLOAT_COUNT];
    void *stack[MAX_STACK_COUNT];
    int stack_flags[MAX_STACK_COUNT];
    int integer_count = 0;
    int float_count = 0;
    int stack_count = 0;
    int stack_size = 0;
    int ii;
    // We need to add a non-removable function call,
    // so the compiler does not generate code for a leaf
    // function. This prevents cloberring our local frame
    // by using it as the red zone for the called function.
    // The == 0 at the end prevents a warning from ignoring
    // its result.
    write(0, NULL, 0) == 0;
    for (ii = 0; ii < count; ii++) {
        if (flags[ii] & ARG_FLAG_FLOAT) {
            if (float_count < MAX_FLOAT_COUNT) {
                floats[float_count++] = args[ii];
                continue;
            }
        } else {
            if (integer_count < MAX_INTEGER_COUNT) {
                integers[integer_count++] = args[ii];
                continue;
            }
        }
        if (stack_count > MAX_STACK_COUNT) {
            *out = strdup("maximum number of stack arguments reached (" _xstr(MAX_STACK_COUNT) ")");
            return 1;
        }
        // Argument on the stack
        stack[stack_count] = args[ii];
        stack_flags[stack_count] = flags[ii];
        stack_count++;
    }
    if (float_count > 0) {
        __asm__(
            "movsd %0, %%xmm0;"
            "movsd %1, %%xmm1;"
            "movsd %2, %%xmm2;"
            "movsd %3, %%xmm3;"
            "movsd %4, %%xmm4;"
            "movsd %5, %%xmm5;"
            "movsd %6, %%xmm6;"
            "movsd %7, %%xmm7;"
            :
            : "m"(floats[0]), "m"(floats[1]), "m"(floats[2]), "m"(floats[3]), "m"(floats[4]), "m"(floats[5]), "m"(floats[6]), "m"(floats[7])
        );
        // Don't set a clobber list here, we want the registers to keep the values we've just set. Instead, set them in
        // the next __asm__ clobber list.
    }
    if (stack_count > 0) {
        *out = strdup("passing arguments on stack not supported yet");
        return 1;
    }
    // Call function and get rax before doing anything
    // else, otherwise the register might get overwritten
    // by the code generated by the if.
    __asm__(
        "movq %2, %%rdi;"
        "movq %3, %%rsi;"
        "movq %4, %%rdx;"
        "movq %5, %%rcx;"
        "movq %6, %%r8;"
        "movq %7, %%r9;"
        "call *%8;"
        "movq %%rax, %0;"
        "movq %%xmm0, %1;"
        : "=r"(ret), "=r"(fret) // Output
        : "m"(integers[0]), "m"(integers[1]), "m"(integers[2]), "m"(integers[3]), "m"(integers[4]), "m"(integers[5]), // Integers
            "r"(f) // Function pointer
        :
            "rax", "rbx", "rcx", "rdx", "rsp", "rbp", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13",
            "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7"
    );
    if (flags[count] & ARG_FLAG_FLOAT) {
        *out = fret;
    } else {
        *out = ret;
    }
    return 0;
}
